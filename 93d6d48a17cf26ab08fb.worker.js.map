{"version":3,"sources":["../webpack/bootstrap","../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","../node_modules/@babel/runtime/helpers/esm/toPrimitive.js","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","utils/graph/common.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/kiwi.js/es/maptype.js","../node_modules/kiwi.js/es/variable.js","../node_modules/kiwi.js/es/expression.js","../node_modules/kiwi.js/es/strength.js","../node_modules/kiwi.js/es/constraint.js","../node_modules/kiwi.js/es/solver.js","utils/graph/solver.js","utils/graph/constraints.js","utils/graph/layout.js","utils/graph/graph.js","utils/graph/routing.js","utils/graph/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_typeof","obj","iterator","constructor","_toPropertyKey","arg","input","hint","prim","toPrimitive","undefined","res","TypeError","String","Number","_defineProperty","configurable","writable","ownKeys","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","arguments","length","source","forEach","getOwnPropertyDescriptors","defineProperties","_arrayLikeToArray","arr","len","arr2","Array","_unsupportedIterableToArray","minLen","toString","slice","from","test","_createForOfIteratorHelper","allowArrayLike","it","isArray","F","done","e","_e","f","err","normalCompletion","didErr","step","next","_e2","HALF_PI","Math","PI","snap","unit","round","angle","a","b","atan2","y","x","nodeLeft","node","width","nodeRight","nodeTop","height","nodeBottom","groupByRow","nodes","_step","rows","_iterator","rowNumbers","map","row","parseFloat","sort","sortedRows","compare","id","_step2","_iterator2","delta","localeCompare","_len","values","_key","nearestOnLine","ax","ay","bx","by","min","max","dx","dy","positionClamped","_toConsumableArray","iter","createMap","IndexedMap","this","index","array","size","empty","itemAt","contains","find","setDefault","factory","pair","Pair","insert","erase","last","pop","first","copy","second","Variable","_value","_context","_id","VarId","_name","setName","context","setContext","setValue","plus","Expression","minus","multiply","coefficient","divide","toJSON","parsed","parseArgs","_terms","terms","_constant","constant","result","isConstant","join","args","item","j","k","terms2","termPair","Error","value2","Operator","Strength","w","clip","required","strong","medium","weak","SymbolType","Constraint","expression","operator","rhs","strength","CnId","_operator","_strength","_expression","op","Solver","_cnMap","_rowMap","_varMap","_editMap","_infeasibleRows","_objective","Row","_artificial","_idTick","createConstraint","lhs","cn","addConstraint","constraint","data","_createRow","tag","subject","_chooseSubject","type","Invalid","allDummies","nearZero","marker","_addWithArtificialVariable","solveFor","_substitute","_optimize","removeConstraint","cnPair","_removeConstraintEffects","rowPair","leaving","_getMarkerLeavingSymbol","solveForEx","hasConstraint","addEditVariable","variable","expr","Eq","info","removeEditVariable","editPair","hasEditVariable","suggestValue","add","_dualOptimize","other","rowPair_1","coeff","coefficientFor","External","updateVariables","vars","_getVarSymbol","_this","_makeSymbol","symbol","basicPair","insertRow","insertSymbol","objective","INVALID_SYMBOL","Le","Ge","slack","Slack","error","errplus","errminus","dummy","Dummy","reverseSign","cells","art","success","basicRow","entering","_anyPivotableSymbol","removeSymbol","substitute","_getEnteringSymbol","_getLeavingSymbol","infeasible","_getDualEnteringSymbol","ratio","MAX_VALUE","found","temp","temp_ratio","dmax","r1","r2","invalid","third","_removeMarkerEffects","_type","_cellMap","theCopy","solveLoose","constraints","iterations","constants","base","solve","solveStrict","solver","variables","variableId","concat","addVariable","_step3","unsolvableCount","_iterator3","strict","console","warn","_i","_variablesList","rowConstraint","variableA","variableB","spaceY","layerConstraint","layerSpace","parallelConstraint","resolve","crossingConstraint","edgeA","edgeB","separationA","separationB","resolveSource","sourceNode","resolveTarget","targetNode","separationConstraint","separation","createRowConstraints","edges","edge","createLayerConstraints","layers","layerConstraints","layerGroups","nearestLayer","layerNodes","nextLayerNodes","intermediary","createCrossingConstraints","spaceX","crossingConstraints","sourceA","targetA","edgeADegree","sources","targets","sourceB","targetB","edgeBDegree","createParallelConstraints","_ref2","createSeparationConstraints","separationConstraints","rowNodes","nodeA","nodeB","degreeA","degreeB","spread","spreadX","space","expandDenseRows","scale","densities","rowDensity","spaceYUnit","currentOffsetY","density","_step4","_iterator4","_step5","_iterator5","edgeAngle","abs","sourceRow","targetRow","defaultOptions","layout","layerSpaceY","padding","routing","minPassageGap","stemUnit","stemMinSource","stemMinTarget","stemMax","stemSpaceSource","stemSpaceTarget","graph","options","addEdgeLinks","addNearestLayers","_ref","rowConstraints","parallelConstraints","_objectSpread","points","sourceOffsetX","indexOf","currentPoint","firstNode","nearestPoint","nearestDistance","Infinity","rowExtended","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","nextNode","nodeGap","offsetX","candidatePoint","distance","offsetY","sourceSeparation","targetSeparation","sourceEdgeDistance","targetEdgeDistance","targetOffsetX","sourceOffsetY","targetOffsetY","sourceStem","targetStem","pointYMax","point","bounds","offset","order","offsetNode","offsetEdge","nodeById","validLayers","layer","hasValidLayer","Boolean","lastLayer","layerNode","findNodeBy","targetNodes","orderRankAscending","rank","successors","accept","visited","successor","graphNew","iconSize","icon","fullName","full_name","textWidth","innerWidth","textOffset","iconOffset","marginx","marginy"],"mappings":"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","file":"93d6d48a17cf26ab08fb.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nexport default function _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}","import _typeof from \"./typeof.js\";\nexport default function _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}","import toPropertyKey from \"./toPropertyKey.js\";\nexport default function _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}","import defineProperty from \"./defineProperty.js\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","/* eslint-disable id-length */\n\n/**\n * PI / 2 constant\n */\n\nexport const HALF_PI = Math.PI * 0.5;\n\n/**\n * Clamps the value between min and max\n * @param {Number} value The number to clamp\n * @param {Number} min The minimum value\n * @param {Number} max The maximum value\n * @returns {Number} The value clamped\n */\nexport const clamp = (value, min, max) =>\n  value < min ? min : value > max ? max : value;\n\n/**\n * Rounds the value to the nearest unit value\n * @param {Number} value The value to snap\n * @param {Number} unit The unit\n * @returns {Number} The value snapped\n */\nexport const snap = (value, unit) => Math.round(value / unit) * unit;\n\n/**\n * Returns the distance between two values\n * @param {Number} a The first value\n * @param {Number} b The second value\n * @returns {Number} The distance\n */\nexport const distance1d = (a, b) => Math.abs(a - b);\n\n/**\n * Returns the angle in radians between the points a and b relative to the X-axis about the origin\n * @param {Object} a The first point\n * @param {Object} b The second point\n * @returns {Number} The angle\n */\nexport const angle = (a, b) => Math.atan2(a.y - b.y, a.x - b.x);\n\n/**\n * Returns the left edge x-position of the node\n * @param {Object} node The node\n * @returns {Number} The left edge position\n */\nexport const nodeLeft = (node) => node.x - node.width * 0.5;\n\n/**\n * Returns the right edge x-position of the node\n * @param {Object} node The node\n * @returns {Number} The right edge position\n */\nexport const nodeRight = (node) => node.x + node.width * 0.5;\n\n/**\n * Returns the top edge y-position of the node\n * @param {Object} node The node\n * @returns {Number} The top edge position\n */\nexport const nodeTop = (node) => node.y - node.height * 0.5;\n\n/**\n * Returns the bottom edge y-position of the node\n * @param {Object} node The node\n * @returns {Number} The bottom edge position\n */\nexport const nodeBottom = (node) => node.y + node.height * 0.5;\n\n/**\n * Finds the rows formed by nodes given the their positions in Y.\n * The result is sorted in X and Y.\n * Adds a `row` property to each node in-place\n * @param {Array} nodes The input nodes\n * @returns {Array} The sorted rows of nodes\n */\nexport const groupByRow = (nodes) => {\n  const rows = {};\n\n  // Create rows using node Y values\n  for (const node of nodes) {\n    rows[node.y] = rows[node.y] || [];\n    rows[node.y].push(node);\n  }\n\n  // Sort the set of rows accounting for keys being strings\n  const rowNumbers = Object.keys(rows).map((row) => parseFloat(row));\n  rowNumbers.sort((a, b) => a - b);\n\n  // Sort rows in order of X position if set. Break ties with ids for stability\n  const sortedRows = rowNumbers.map((row) => rows[row]);\n  for (let i = 0; i < sortedRows.length; i += 1) {\n    sortedRows[i].sort((a, b) => compare(a.x, b.x, a.id, b.id));\n\n    for (const node of sortedRows[i]) {\n      node.row = i;\n    }\n  }\n\n  return sortedRows;\n};\n\n/**\n * Generalised comparator function for sorting\n * If values are strings then `localeCompare` is used, otherwise values are subtracted\n * Compares the first pair of values and returns the difference if non equal,\n * otherwise ties are broken by comparing the subsequent pairs of values\n * @param {Number|String} a Value to compare with `b`\n * @param {Number|String} b Value to compare with `a`\n * @param {...Number|String} values Any number of further pairs of values to compare as tie-breakers\n * @returns {Number} A standard signed comparator result\n */\nexport const compare = (a, b, ...values) => {\n  const delta = typeof a === 'string' ? a.localeCompare(b) : a - b;\n  return delta !== 0 || values.length === 0 ? delta : compare(...values);\n};\n\n/**\n * Returns the node with the position translated in-place\n * @param {Object} node The node\n * @param {Object} offset The translation vector\n * @returns {Object} The node\n */\nexport const offsetNode = (node, offset) => {\n  node.x = node.x - offset.x;\n  node.y = node.y - offset.y;\n  // Node sort order for tabindex:\n  node.order = node.x + node.y * 9999;\n  return node;\n};\n\n/**\n * Returns the edge with each point translated in-place\n * @param {Object} edge The edge\n * @param {Object} offset The translation vector\n * @returns {Object} The edge\n */\nexport const offsetEdge = (edge, offset) => {\n  edge.points.forEach((point) => {\n    point.x = point.x - offset.x;\n    point.y = point.y - offset.y;\n  });\n  return edge;\n};\n\n/**\n * Returns the point on the line segment `ax, ay, bx, by` closest to point `x, y`\n * @param {Number} x The test point x\n * @param {Number} y The test point y\n * @param {Number} ax The start of the line segement x point\n * @param {Number} ay The start of the line segement y point\n * @param {Number} bx The end of the line segement x point\n * @param {Number} by The end of the line segement y point\n * @returns {Object} An object with the closest point and both line segment points\n */\nexport const nearestOnLine = (x, y, ax, ay, bx, by) => {\n  const dx = bx - ax;\n  const dy = by - ay;\n  const position = ((x - ax) * dx + (y - ay) * dy) / (dx * dx + dy * dy || 1);\n  const positionClamped = clamp(position, 0, 1);\n\n  return {\n    x: ax + dx * positionClamped,\n    y: ay + dy * positionClamped,\n    ax,\n    ay,\n    bx,\n    by,\n  };\n};\n","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nexport function createMap() {\n    return new IndexedMap();\n}\nvar IndexedMap = /** @class */ (function () {\n    function IndexedMap() {\n        this.index = {};\n        this.array = [];\n    }\n    /**\n     * Returns the number of items in the array.\n     */\n    IndexedMap.prototype.size = function () {\n        return this.array.length;\n    };\n    /**\n     * Returns true if the array is empty.\n     */\n    IndexedMap.prototype.empty = function () {\n        return this.array.length === 0;\n    };\n    /**\n     * Returns the item at the given array index.\n     *\n     * @param index The integer index of the desired item.\n     */\n    IndexedMap.prototype.itemAt = function (index) {\n        return this.array[index];\n    };\n    /**\n     * Returns true if the key is in the array, false otherwise.\n     *\n     * @param key The key to locate in the array.\n     */\n    IndexedMap.prototype.contains = function (key) {\n        return this.index[key.id()] !== undefined;\n    };\n    /**\n     * Returns the pair associated with the given key, or undefined.\n     *\n     * @param key The key to locate in the array.\n     */\n    IndexedMap.prototype.find = function (key) {\n        var i = this.index[key.id()];\n        return i === undefined ? undefined : this.array[i];\n    };\n    /**\n     * Returns the pair associated with the key if it exists.\n     *\n     * If the key does not exist, a new pair will be created and\n     * inserted using the value created by the given factory.\n     *\n     * @param key The key to locate in the array.\n     * @param factory The function which creates the default value.\n     */\n    IndexedMap.prototype.setDefault = function (key, factory) {\n        var i = this.index[key.id()];\n        if (i === undefined) {\n            var pair = new Pair(key, factory());\n            this.index[key.id()] = this.array.length;\n            this.array.push(pair);\n            return pair;\n        }\n        else {\n            return this.array[i];\n        }\n    };\n    /**\n     * Insert the pair into the array and return the pair.\n     *\n     * This will overwrite any existing entry in the array.\n     *\n     * @param key The key portion of the pair.\n     * @param value The value portion of the pair.\n     */\n    IndexedMap.prototype.insert = function (key, value) {\n        var pair = new Pair(key, value);\n        var i = this.index[key.id()];\n        if (i === undefined) {\n            this.index[key.id()] = this.array.length;\n            this.array.push(pair);\n        }\n        else {\n            this.array[i] = pair;\n        }\n        return pair;\n    };\n    /**\n     * Removes and returns the pair for the given key, or undefined.\n     *\n     * @param key The key to remove from the map.\n     */\n    IndexedMap.prototype.erase = function (key) {\n        var i = this.index[key.id()];\n        if (i === undefined) {\n            return undefined;\n        }\n        this.index[key.id()] = undefined;\n        var pair = this.array[i];\n        var last = this.array.pop();\n        if (pair !== last) {\n            this.array[i] = last;\n            this.index[last.first.id()] = i;\n        }\n        return pair;\n    };\n    /**\n     * Create a copy of this associative array.\n     */\n    IndexedMap.prototype.copy = function () {\n        var copy = new IndexedMap();\n        for (var i = 0; i < this.array.length; i++) {\n            var pair = this.array[i].copy();\n            copy.array[i] = pair;\n            copy.index[pair.first.id()] = i;\n        }\n        return copy;\n    };\n    return IndexedMap;\n}());\n/**\n * A class which defines a generic pair object.\n * @private\n */\n// tslint:disable: max-classes-per-file\nvar Pair = /** @class */ (function () {\n    /**\n     * Construct a new Pair object.\n     *\n     * @param first The first item of the pair.\n     * @param second The second item of the pair.\n     */\n    function Pair(first, second) {\n        this.first = first;\n        this.second = second;\n    }\n    /**\n     * Create a copy of the pair.\n     */\n    Pair.prototype.copy = function () { return new Pair(this.first, this.second); };\n    return Pair;\n}());\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { Expression } from \"./expression\";\n/**\n * The primary user constraint variable.\n *\n * @class\n * @param {String} [name=\"\"] The name to associated with the variable.\n */\nvar Variable = /** @class */ (function () {\n    function Variable(name) {\n        if (name === void 0) { name = \"\"; }\n        this._value = 0.0;\n        this._context = null;\n        this._id = VarId++;\n        this._name = name;\n    }\n    /**\n     * Returns the unique id number of the variable.\n     * @private\n     */\n    Variable.prototype.id = function () {\n        return this._id;\n    };\n    /**\n     * Returns the name of the variable.\n     *\n     * @return {String} name of the variable\n     */\n    Variable.prototype.name = function () {\n        return this._name;\n    };\n    /**\n     * Set the name of the variable.\n     *\n     * @param {String} name Name of the variable\n     */\n    Variable.prototype.setName = function (name) {\n        this._name = name;\n    };\n    /**\n     * Returns the user context object of the variable.\n     * @private\n     */\n    Variable.prototype.context = function () {\n        return this._context;\n    };\n    /**\n     * Set the user context object of the variable.\n     * @private\n     */\n    Variable.prototype.setContext = function (context) {\n        this._context = context;\n    };\n    /**\n     * Returns the value of the variable.\n     *\n     * @return {Number} Calculated value\n     */\n    Variable.prototype.value = function () {\n        return this._value;\n    };\n    /**\n     * Set the value of the variable.\n     * @private\n     */\n    Variable.prototype.setValue = function (value) {\n        this._value = value;\n    };\n    /**\n     * Creates a new Expression by adding a number, variable or expression\n     * to the variable.\n     *\n     * @param {Number|Variable|Expression} value Value to add.\n     * @return {Expression} expression\n     */\n    Variable.prototype.plus = function (value) {\n        return new Expression(this, value);\n    };\n    /**\n     * Creates a new Expression by substracting a number, variable or expression\n     * from the variable.\n     *\n     * @param {Number|Variable|Expression} value Value to substract.\n     * @return {Expression} expression\n     */\n    Variable.prototype.minus = function (value) {\n        return new Expression(this, typeof value === \"number\" ? -value : [-1, value]);\n    };\n    /**\n     * Creates a new Expression by multiplying with a fixed number.\n     *\n     * @param {Number} coefficient Coefficient to multiply with.\n     * @return {Expression} expression\n     */\n    Variable.prototype.multiply = function (coefficient) {\n        return new Expression([coefficient, this]);\n    };\n    /**\n     * Creates a new Expression by dividing with a fixed number.\n     *\n     * @param {Number} coefficient Coefficient to divide by.\n     * @return {Expression} expression\n     */\n    Variable.prototype.divide = function (coefficient) {\n        return new Expression([1 / coefficient, this]);\n    };\n    /**\n     * Returns the JSON representation of the variable.\n     * @private\n     */\n    Variable.prototype.toJSON = function () {\n        return {\n            name: this._name,\n            value: this._value,\n        };\n    };\n    Variable.prototype.toString = function () {\n        return this._context + \"[\" + this._name + \":\" + this._value + \"]\";\n    };\n    return Variable;\n}());\nexport { Variable };\n/**\n * The internal variable id counter.\n * @private\n */\nvar VarId = 0;\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { createMap } from \"./maptype\";\nimport { Variable } from \"./variable\";\n/**\n * An expression of variable terms and a constant.\n *\n * The constructor accepts an arbitrary number of parameters,\n * each of which must be one of the following types:\n *  - number\n *  - Variable\n *  - Expression\n *  - 2-tuple of [number, Variable|Expression]\n *\n * The parameters are summed. The tuples are multiplied.\n *\n * @class\n * @param {...(number|Variable|Expression|Array)} args\n */\nvar Expression = /** @class */ (function () {\n    function Expression() {\n        var parsed = parseArgs(arguments);\n        this._terms = parsed.terms;\n        this._constant = parsed.constant;\n    }\n    /**\n     * Returns the mapping of terms in the expression.\n     *\n     * This *must* be treated as const.\n     * @private\n     */\n    Expression.prototype.terms = function () {\n        return this._terms;\n    };\n    /**\n     * Returns the constant of the expression.\n     * @private\n     */\n    Expression.prototype.constant = function () {\n        return this._constant;\n    };\n    /**\n     * Returns the computed value of the expression.\n     *\n     * @private\n     * @return {Number} computed value of the expression\n     */\n    Expression.prototype.value = function () {\n        var result = this._constant;\n        for (var i = 0, n = this._terms.size(); i < n; i++) {\n            var pair = this._terms.itemAt(i);\n            result += pair.first.value() * pair.second;\n        }\n        return result;\n    };\n    /**\n     * Creates a new Expression by adding a number, variable or expression\n     * to the expression.\n     *\n     * @param {Number|Variable|Expression} value Value to add.\n     * @return {Expression} expression\n     */\n    Expression.prototype.plus = function (value) {\n        return new Expression(this, value);\n    };\n    /**\n     * Creates a new Expression by substracting a number, variable or expression\n     * from the expression.\n     *\n     * @param {Number|Variable|Expression} value Value to substract.\n     * @return {Expression} expression\n     */\n    Expression.prototype.minus = function (value) {\n        return new Expression(this, typeof value === \"number\" ? -value : [-1, value]);\n    };\n    /**\n     * Creates a new Expression by multiplying with a fixed number.\n     *\n     * @param {Number} coefficient Coefficient to multiply with.\n     * @return {Expression} expression\n     */\n    Expression.prototype.multiply = function (coefficient) {\n        return new Expression([coefficient, this]);\n    };\n    /**\n     * Creates a new Expression by dividing with a fixed number.\n     *\n     * @param {Number} coefficient Coefficient to divide by.\n     * @return {Expression} expression\n     */\n    Expression.prototype.divide = function (coefficient) {\n        return new Expression([1 / coefficient, this]);\n    };\n    Expression.prototype.isConstant = function () {\n        return this._terms.size() == 0;\n    };\n    Expression.prototype.toString = function () {\n        var result = this._terms.array.map(function (pair) {\n            return (pair.second + \"*\" + pair.first.toString());\n        }).join(\" + \");\n        if (!this.isConstant() && this._constant !== 0) {\n            result += \" + \";\n        }\n        result += this._constant;\n        return result;\n    };\n    return Expression;\n}());\nexport { Expression };\n/**\n * An internal argument parsing function.\n * @private\n */\nfunction parseArgs(args) {\n    var constant = 0.0;\n    var factory = function () { return 0.0; };\n    var terms = createMap();\n    for (var i = 0, n = args.length; i < n; ++i) {\n        var item = args[i];\n        if (typeof item === \"number\") {\n            constant += item;\n        }\n        else if (item instanceof Variable) {\n            terms.setDefault(item, factory).second += 1.0;\n        }\n        else if (item instanceof Expression) {\n            constant += item.constant();\n            var terms2 = item.terms();\n            for (var j = 0, k = terms2.size(); j < k; j++) {\n                var termPair = terms2.itemAt(j);\n                terms.setDefault(termPair.first, factory).second += termPair.second;\n            }\n        }\n        else if (item instanceof Array) {\n            if (item.length !== 2) {\n                throw new Error(\"array must have length 2\");\n            }\n            var value = item[0];\n            var value2 = item[1];\n            if (typeof value !== \"number\") {\n                throw new Error(\"array item 0 must be a number\");\n            }\n            if (value2 instanceof Variable) {\n                terms.setDefault(value2, factory).second += value;\n            }\n            else if (value2 instanceof Expression) {\n                constant += (value2.constant() * value);\n                var terms2 = value2.terms();\n                for (var j = 0, k = terms2.size(); j < k; j++) {\n                    var termPair = terms2.itemAt(j);\n                    terms.setDefault(termPair.first, factory).second += (termPair.second * value);\n                }\n            }\n            else {\n                throw new Error(\"array item 1 must be a variable or expression\");\n            }\n        }\n        else {\n            throw new Error(\"invalid Expression argument: \" + item);\n        }\n    }\n    return { terms: terms, constant: constant };\n}\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * @class Strength\n */\nvar Strength = /** @class */ (function () {\n    function Strength() {\n    }\n    /**\n     * Create a new symbolic strength.\n     *\n     * @param a strong\n     * @param b medium\n     * @param c weak\n     * @param [w] weight\n     * @return strength\n    */\n    Strength.create = function (a, b, c, w) {\n        if (w === void 0) { w = 1.0; }\n        var result = 0.0;\n        result += Math.max(0.0, Math.min(1000.0, a * w)) * 1000000.0;\n        result += Math.max(0.0, Math.min(1000.0, b * w)) * 1000.0;\n        result += Math.max(0.0, Math.min(1000.0, c * w));\n        return result;\n    };\n    /**\n     * Clip a symbolic strength to the allowed min and max.\n     * @private\n     */\n    Strength.clip = function (value) {\n        return Math.max(0.0, Math.min(Strength.required, value));\n    };\n    /**\n     * The 'required' symbolic strength.\n     */\n    Strength.required = Strength.create(1000.0, 1000.0, 1000.0);\n    /**\n     * The 'strong' symbolic strength.\n     */\n    Strength.strong = Strength.create(1.0, 0.0, 0.0);\n    /**\n     * The 'medium' symbolic strength.\n     */\n    Strength.medium = Strength.create(0.0, 1.0, 0.0);\n    /**\n     * The 'weak' symbolic strength.\n     */\n    Strength.weak = Strength.create(0.0, 0.0, 1.0);\n    return Strength;\n}());\nexport { Strength };\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { Expression } from \"./expression\";\nimport { Strength } from \"./strength\";\n/**\n * An enum defining the linear constraint operators.\n *\n * |Value|Operator|Description|\n * |----|-----|-----|\n * |`Le`|<=|Less than equal|\n * |`Ge`|>=|Greater than equal|\n * |`Eq`|==|Equal|\n *\n * @enum {Number}\n */\nexport var Operator;\n(function (Operator) {\n    Operator[Operator[\"Le\"] = 0] = \"Le\";\n    Operator[Operator[\"Ge\"] = 1] = \"Ge\";\n    Operator[Operator[\"Eq\"] = 2] = \"Eq\";\n})(Operator || (Operator = {}));\n/**\n * A linear constraint equation.\n *\n * A constraint equation is composed of an expression, an operator,\n * and a strength. The RHS of the equation is implicitly zero.\n *\n * @class\n * @param {Expression} expression The constraint expression (LHS).\n * @param {Operator} operator The equation operator.\n * @param {Expression} [rhs] Right hand side of the expression.\n * @param {Number} [strength=Strength.required] The strength of the constraint.\n */\nvar Constraint = /** @class */ (function () {\n    function Constraint(expression, operator, rhs, strength) {\n        if (strength === void 0) { strength = Strength.required; }\n        this._id = CnId++;\n        this._operator = operator;\n        this._strength = Strength.clip(strength);\n        if ((rhs === undefined) && (expression instanceof Expression)) {\n            this._expression = expression;\n        }\n        else {\n            this._expression = expression.minus(rhs);\n        }\n    }\n    /**\n     * Returns the unique id number of the constraint.\n     * @private\n     */\n    Constraint.prototype.id = function () {\n        return this._id;\n    };\n    /**\n     * Returns the expression of the constraint.\n     *\n     * @return {Expression} expression\n     */\n    Constraint.prototype.expression = function () {\n        return this._expression;\n    };\n    /**\n     * Returns the relational operator of the constraint.\n     *\n     * @return {Operator} linear constraint operator\n     */\n    Constraint.prototype.op = function () {\n        return this._operator;\n    };\n    /**\n     * Returns the strength of the constraint.\n     *\n     * @return {Number} strength\n     */\n    Constraint.prototype.strength = function () {\n        return this._strength;\n    };\n    Constraint.prototype.toString = function () {\n        return this._expression.toString() + \" \" + [\"<=\", \">=\", \"=\"][this._operator] + \" 0 (\" + this._strength.toString() + \")\";\n    };\n    return Constraint;\n}());\nexport { Constraint };\n/**\n * The internal constraint id counter.\n * @private\n */\nvar CnId = 0;\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { Constraint, Operator } from \"./constraint\";\nimport { Expression } from \"./expression\";\nimport { createMap } from \"./maptype\";\nimport { Strength } from \"./strength\";\n/**\n * The constraint solver class.\n *\n * @class\n */\nvar Solver = /** @class */ (function () {\n    /**\n     * Construct a new Solver.\n     */\n    function Solver() {\n        this._cnMap = createCnMap();\n        this._rowMap = createRowMap();\n        this._varMap = createVarMap();\n        this._editMap = createEditMap();\n        this._infeasibleRows = [];\n        this._objective = new Row();\n        this._artificial = null;\n        this._idTick = 0;\n    }\n    /**\n     * Creates and add a constraint to the solver.\n     *\n     * @param {Expression|Variable} lhs Left hand side of the expression\n     * @param {Operator} operator Operator\n     * @param {Expression|Variable|Number} rhs Right hand side of the expression\n     * @param {Number} [strength=Strength.required] Strength\n     */\n    Solver.prototype.createConstraint = function (lhs, operator, rhs, strength) {\n        if (strength === void 0) { strength = Strength.required; }\n        var cn = new Constraint(lhs, operator, rhs, strength);\n        this.addConstraint(cn);\n        return cn;\n    };\n    /**\n     * Add a constraint to the solver.\n     *\n     * @param {Constraint} constraint Constraint to add to the solver\n     */\n    Solver.prototype.addConstraint = function (constraint) {\n        var cnPair = this._cnMap.find(constraint);\n        if (cnPair !== undefined) {\n            throw new Error(\"duplicate constraint\");\n        }\n        // Creating a row causes symbols to be reserved for the variables\n        // in the constraint. If this method exits with an exception,\n        // then its possible those variables will linger in the var map.\n        // Since its likely that those variables will be used in other\n        // constraints and since exceptional conditions are uncommon,\n        // i'm not too worried about aggressive cleanup of the var map.\n        var data = this._createRow(constraint);\n        var row = data.row;\n        var tag = data.tag;\n        var subject = this._chooseSubject(row, tag);\n        // If chooseSubject couldnt find a valid entering symbol, one\n        // last option is available if the entire row is composed of\n        // dummy variables. If the constant of the row is zero, then\n        // this represents redundant constraints and the new dummy\n        // marker can enter the basis. If the constant is non-zero,\n        // then it represents an unsatisfiable constraint.\n        if (subject.type() === SymbolType.Invalid && row.allDummies()) {\n            if (!nearZero(row.constant())) {\n                throw new Error(\"unsatisfiable constraint\");\n            }\n            else {\n                subject = tag.marker;\n            }\n        }\n        // If an entering symbol still isn't found, then the row must\n        // be added using an artificial variable. If that fails, then\n        // the row represents an unsatisfiable constraint.\n        if (subject.type() === SymbolType.Invalid) {\n            if (!this._addWithArtificialVariable(row)) {\n                throw new Error(\"unsatisfiable constraint\");\n            }\n        }\n        else {\n            row.solveFor(subject);\n            this._substitute(subject, row);\n            this._rowMap.insert(subject, row);\n        }\n        this._cnMap.insert(constraint, tag);\n        // Optimizing after each constraint is added performs less\n        // aggregate work due to a smaller average system size. It\n        // also ensures the solver remains in a consistent state.\n        this._optimize(this._objective);\n    };\n    /**\n     * Remove a constraint from the solver.\n     *\n     * @param {Constraint} constraint Constraint to remove from the solver\n     */\n    Solver.prototype.removeConstraint = function (constraint) {\n        var cnPair = this._cnMap.erase(constraint);\n        if (cnPair === undefined) {\n            throw new Error(\"unknown constraint\");\n        }\n        // Remove the error effects from the objective function\n        // *before* pivoting, or substitutions into the objective\n        // will lead to incorrect solver results.\n        this._removeConstraintEffects(constraint, cnPair.second);\n        // If the marker is basic, simply drop the row. Otherwise,\n        // pivot the marker into the basis and then drop the row.\n        var marker = cnPair.second.marker;\n        var rowPair = this._rowMap.erase(marker);\n        if (rowPair === undefined) {\n            var leaving = this._getMarkerLeavingSymbol(marker);\n            if (leaving.type() === SymbolType.Invalid) {\n                throw new Error(\"failed to find leaving row\");\n            }\n            rowPair = this._rowMap.erase(leaving);\n            rowPair.second.solveForEx(leaving, marker);\n            this._substitute(marker, rowPair.second);\n        }\n        // Optimizing after each constraint is removed ensures that the\n        // solver remains consistent. It makes the solver api easier to\n        // use at a small tradeoff for speed.\n        this._optimize(this._objective);\n    };\n    /**\n     * Test whether the solver contains the constraint.\n     *\n     * @param {Constraint} constraint Constraint to test for\n     * @return {Bool} true or false\n     */\n    Solver.prototype.hasConstraint = function (constraint) {\n        return this._cnMap.contains(constraint);\n    };\n    /**\n     * Add an edit variable to the solver.\n     *\n     * @param {Variable} variable Edit variable to add to the solver\n     * @param {Number} strength Strength, should be less than `Strength.required`\n     */\n    Solver.prototype.addEditVariable = function (variable, strength) {\n        var editPair = this._editMap.find(variable);\n        if (editPair !== undefined) {\n            throw new Error(\"duplicate edit variable\");\n        }\n        strength = Strength.clip(strength);\n        if (strength === Strength.required) {\n            throw new Error(\"bad required strength\");\n        }\n        var expr = new Expression(variable);\n        var cn = new Constraint(expr, Operator.Eq, undefined, strength);\n        this.addConstraint(cn);\n        var tag = this._cnMap.find(cn).second;\n        var info = { tag: tag, constraint: cn, constant: 0.0 };\n        this._editMap.insert(variable, info);\n    };\n    /**\n     * Remove an edit variable from the solver.\n     *\n     * @param {Variable} variable Edit variable to remove from the solver\n     */\n    Solver.prototype.removeEditVariable = function (variable) {\n        var editPair = this._editMap.erase(variable);\n        if (editPair === undefined) {\n            throw new Error(\"unknown edit variable\");\n        }\n        this.removeConstraint(editPair.second.constraint);\n    };\n    /**\n     * Test whether the solver contains the edit variable.\n     *\n     * @param {Variable} variable Edit variable to test for\n     * @return {Bool} true or false\n     */\n    Solver.prototype.hasEditVariable = function (variable) {\n        return this._editMap.contains(variable);\n    };\n    /**\n     * Suggest the value of an edit variable.\n     *\n     * @param {Variable} variable Edit variable to suggest a value for\n     * @param {Number} value Suggested value\n     */\n    Solver.prototype.suggestValue = function (variable, value) {\n        var editPair = this._editMap.find(variable);\n        if (editPair === undefined) {\n            throw new Error(\"unknown edit variable\");\n        }\n        var rows = this._rowMap;\n        var info = editPair.second;\n        var delta = value - info.constant;\n        info.constant = value;\n        // Check first if the positive error variable is basic.\n        var marker = info.tag.marker;\n        var rowPair = rows.find(marker);\n        if (rowPair !== undefined) {\n            if (rowPair.second.add(-delta) < 0.0) {\n                this._infeasibleRows.push(marker);\n            }\n            this._dualOptimize();\n            return;\n        }\n        // Check next if the negative error variable is basic.\n        var other = info.tag.other;\n        rowPair = rows.find(other);\n        if (rowPair !== undefined) {\n            if (rowPair.second.add(delta) < 0.0) {\n                this._infeasibleRows.push(other);\n            }\n            this._dualOptimize();\n            return;\n        }\n        // Otherwise update each row where the error variables exist.\n        for (var i = 0, n = rows.size(); i < n; ++i) {\n            var rowPair_1 = rows.itemAt(i);\n            var row = rowPair_1.second;\n            var coeff = row.coefficientFor(marker);\n            if (coeff !== 0.0 && row.add(delta * coeff) < 0.0 &&\n                rowPair_1.first.type() !== SymbolType.External) {\n                this._infeasibleRows.push(rowPair_1.first);\n            }\n        }\n        this._dualOptimize();\n    };\n    /**\n     * Update the values of the variables.\n     */\n    Solver.prototype.updateVariables = function () {\n        var vars = this._varMap;\n        var rows = this._rowMap;\n        for (var i = 0, n = vars.size(); i < n; ++i) {\n            var pair = vars.itemAt(i);\n            var rowPair = rows.find(pair.second);\n            if (rowPair !== undefined) {\n                pair.first.setValue(rowPair.second.constant());\n            }\n            else {\n                pair.first.setValue(0.0);\n            }\n        }\n    };\n    /**\n     * Get the symbol for the given variable.\n     *\n     * If a symbol does not exist for the variable, one will be created.\n     * @private\n     */\n    Solver.prototype._getVarSymbol = function (variable) {\n        var _this = this;\n        var factory = function () { return _this._makeSymbol(SymbolType.External); };\n        return this._varMap.setDefault(variable, factory).second;\n    };\n    /**\n     * Create a new Row object for the given constraint.\n     *\n     * The terms in the constraint will be converted to cells in the row.\n     * Any term in the constraint with a coefficient of zero is ignored.\n     * This method uses the `_getVarSymbol` method to get the symbol for\n     * the variables added to the row. If the symbol for a given cell\n     * variable is basic, the cell variable will be substituted with the\n     * basic row.\n     *\n     * The necessary slack and error variables will be added to the row.\n     * If the constant for the row is negative, the sign for the row\n     * will be inverted so the constant becomes positive.\n     *\n     * Returns the created Row and the tag for tracking the constraint.\n     * @private\n     */\n    Solver.prototype._createRow = function (constraint) {\n        var expr = constraint.expression();\n        var row = new Row(expr.constant());\n        // Substitute the current basic variables into the row.\n        var terms = expr.terms();\n        for (var i = 0, n = terms.size(); i < n; ++i) {\n            var termPair = terms.itemAt(i);\n            if (!nearZero(termPair.second)) {\n                var symbol = this._getVarSymbol(termPair.first);\n                var basicPair = this._rowMap.find(symbol);\n                if (basicPair !== undefined) {\n                    row.insertRow(basicPair.second, termPair.second);\n                }\n                else {\n                    row.insertSymbol(symbol, termPair.second);\n                }\n            }\n        }\n        // Add the necessary slack, error, and dummy variables.\n        var objective = this._objective;\n        var strength = constraint.strength();\n        var tag = { marker: INVALID_SYMBOL, other: INVALID_SYMBOL };\n        switch (constraint.op()) {\n            case Operator.Le:\n            case Operator.Ge:\n                {\n                    var coeff = constraint.op() === Operator.Le ? 1.0 : -1.0;\n                    var slack = this._makeSymbol(SymbolType.Slack);\n                    tag.marker = slack;\n                    row.insertSymbol(slack, coeff);\n                    if (strength < Strength.required) {\n                        var error = this._makeSymbol(SymbolType.Error);\n                        tag.other = error;\n                        row.insertSymbol(error, -coeff);\n                        objective.insertSymbol(error, strength);\n                    }\n                    break;\n                }\n            case Operator.Eq:\n                {\n                    if (strength < Strength.required) {\n                        var errplus = this._makeSymbol(SymbolType.Error);\n                        var errminus = this._makeSymbol(SymbolType.Error);\n                        tag.marker = errplus;\n                        tag.other = errminus;\n                        row.insertSymbol(errplus, -1.0); // v = eplus - eminus\n                        row.insertSymbol(errminus, 1.0); // v - eplus + eminus = 0\n                        objective.insertSymbol(errplus, strength);\n                        objective.insertSymbol(errminus, strength);\n                    }\n                    else {\n                        var dummy = this._makeSymbol(SymbolType.Dummy);\n                        tag.marker = dummy;\n                        row.insertSymbol(dummy);\n                    }\n                    break;\n                }\n        }\n        // Ensure the row has a positive constant.\n        if (row.constant() < 0.0) {\n            row.reverseSign();\n        }\n        return { row: row, tag: tag };\n    };\n    /**\n     * Choose the subject for solving for the row.\n     *\n     * This method will choose the best subject for using as the solve\n     * target for the row. An invalid symbol will be returned if there\n     * is no valid target.\n     *\n     * The symbols are chosen according to the following precedence:\n     *\n     * 1) The first symbol representing an external variable.\n     * 2) A negative slack or error tag variable.\n     *\n     * If a subject cannot be found, an invalid symbol will be returned.\n     *\n     * @private\n     */\n    Solver.prototype._chooseSubject = function (row, tag) {\n        var cells = row.cells();\n        for (var i = 0, n = cells.size(); i < n; ++i) {\n            var pair = cells.itemAt(i);\n            if (pair.first.type() === SymbolType.External) {\n                return pair.first;\n            }\n        }\n        var type = tag.marker.type();\n        if (type === SymbolType.Slack || type === SymbolType.Error) {\n            if (row.coefficientFor(tag.marker) < 0.0) {\n                return tag.marker;\n            }\n        }\n        type = tag.other.type();\n        if (type === SymbolType.Slack || type === SymbolType.Error) {\n            if (row.coefficientFor(tag.other) < 0.0) {\n                return tag.other;\n            }\n        }\n        return INVALID_SYMBOL;\n    };\n    /**\n     * Add the row to the tableau using an artificial variable.\n     *\n     * This will return false if the constraint cannot be satisfied.\n     *\n     * @private\n     */\n    Solver.prototype._addWithArtificialVariable = function (row) {\n        // Create and add the artificial variable to the tableau.\n        var art = this._makeSymbol(SymbolType.Slack);\n        this._rowMap.insert(art, row.copy());\n        this._artificial = row.copy();\n        // Optimize the artificial objective. This is successful\n        // only if the artificial objective is optimized to zero.\n        this._optimize(this._artificial);\n        var success = nearZero(this._artificial.constant());\n        this._artificial = null;\n        // If the artificial variable is basic, pivot the row so that\n        // it becomes non-basic. If the row is constant, exit early.\n        var pair = this._rowMap.erase(art);\n        if (pair !== undefined) {\n            var basicRow = pair.second;\n            if (basicRow.isConstant()) {\n                return success;\n            }\n            var entering = this._anyPivotableSymbol(basicRow);\n            if (entering.type() === SymbolType.Invalid) {\n                return false; // unsatisfiable (will this ever happen?)\n            }\n            basicRow.solveForEx(art, entering);\n            this._substitute(entering, basicRow);\n            this._rowMap.insert(entering, basicRow);\n        }\n        // Remove the artificial variable from the tableau.\n        var rows = this._rowMap;\n        for (var i = 0, n = rows.size(); i < n; ++i) {\n            rows.itemAt(i).second.removeSymbol(art);\n        }\n        this._objective.removeSymbol(art);\n        return success;\n    };\n    /**\n     * Substitute the parametric symbol with the given row.\n     *\n     * This method will substitute all instances of the parametric symbol\n     * in the tableau and the objective function with the given row.\n     *\n     * @private\n     */\n    Solver.prototype._substitute = function (symbol, row) {\n        var rows = this._rowMap;\n        for (var i = 0, n = rows.size(); i < n; ++i) {\n            var pair = rows.itemAt(i);\n            pair.second.substitute(symbol, row);\n            if (pair.second.constant() < 0.0 &&\n                pair.first.type() !== SymbolType.External) {\n                this._infeasibleRows.push(pair.first);\n            }\n        }\n        this._objective.substitute(symbol, row);\n        if (this._artificial) {\n            this._artificial.substitute(symbol, row);\n        }\n    };\n    /**\n     * Optimize the system for the given objective function.\n     *\n     * This method performs iterations of Phase 2 of the simplex method\n     * until the objective function reaches a minimum.\n     *\n     * @private\n     */\n    Solver.prototype._optimize = function (objective) {\n        while (true) {\n            var entering = this._getEnteringSymbol(objective);\n            if (entering.type() === SymbolType.Invalid) {\n                return;\n            }\n            var leaving = this._getLeavingSymbol(entering);\n            if (leaving.type() === SymbolType.Invalid) {\n                throw new Error(\"the objective is unbounded\");\n            }\n            // pivot the entering symbol into the basis\n            var row = this._rowMap.erase(leaving).second;\n            row.solveForEx(leaving, entering);\n            this._substitute(entering, row);\n            this._rowMap.insert(entering, row);\n        }\n    };\n    /**\n     * Optimize the system using the dual of the simplex method.\n     *\n     * The current state of the system should be such that the objective\n     * function is optimal, but not feasible. This method will perform\n     * an iteration of the dual simplex method to make the solution both\n     * optimal and feasible.\n     *\n     * @private\n     */\n    Solver.prototype._dualOptimize = function () {\n        var rows = this._rowMap;\n        var infeasible = this._infeasibleRows;\n        while (infeasible.length !== 0) {\n            var leaving = infeasible.pop();\n            var pair = rows.find(leaving);\n            if (pair !== undefined && pair.second.constant() < 0.0) {\n                var entering = this._getDualEnteringSymbol(pair.second);\n                if (entering.type() === SymbolType.Invalid) {\n                    throw new Error(\"dual optimize failed\");\n                }\n                // pivot the entering symbol into the basis\n                var row = pair.second;\n                rows.erase(leaving);\n                row.solveForEx(leaving, entering);\n                this._substitute(entering, row);\n                rows.insert(entering, row);\n            }\n        }\n    };\n    /**\n     * Compute the entering variable for a pivot operation.\n     *\n     * This method will return first symbol in the objective function which\n     * is non-dummy and has a coefficient less than zero. If no symbol meets\n     * the criteria, it means the objective function is at a minimum, and an\n     * invalid symbol is returned.\n     *\n     * @private\n     */\n    Solver.prototype._getEnteringSymbol = function (objective) {\n        var cells = objective.cells();\n        for (var i = 0, n = cells.size(); i < n; ++i) {\n            var pair = cells.itemAt(i);\n            var symbol = pair.first;\n            if (pair.second < 0.0 && symbol.type() !== SymbolType.Dummy) {\n                return symbol;\n            }\n        }\n        return INVALID_SYMBOL;\n    };\n    /**\n     * Compute the entering symbol for the dual optimize operation.\n     *\n     * This method will return the symbol in the row which has a positive\n     * coefficient and yields the minimum ratio for its respective symbol\n     * in the objective function. The provided row *must* be infeasible.\n     * If no symbol is found which meats the criteria, an invalid symbol\n     * is returned.\n     *\n     * @private\n     */\n    Solver.prototype._getDualEnteringSymbol = function (row) {\n        var ratio = Number.MAX_VALUE;\n        var entering = INVALID_SYMBOL;\n        var cells = row.cells();\n        for (var i = 0, n = cells.size(); i < n; ++i) {\n            var pair = cells.itemAt(i);\n            var symbol = pair.first;\n            var c = pair.second;\n            if (c > 0.0 && symbol.type() !== SymbolType.Dummy) {\n                var coeff = this._objective.coefficientFor(symbol);\n                var r = coeff / c;\n                if (r < ratio) {\n                    ratio = r;\n                    entering = symbol;\n                }\n            }\n        }\n        return entering;\n    };\n    /**\n     * Compute the symbol for pivot exit row.\n     *\n     * This method will return the symbol for the exit row in the row\n     * map. If no appropriate exit symbol is found, an invalid symbol\n     * will be returned. This indicates that the objective function is\n     * unbounded.\n     *\n     * @private\n     */\n    Solver.prototype._getLeavingSymbol = function (entering) {\n        var ratio = Number.MAX_VALUE;\n        var found = INVALID_SYMBOL;\n        var rows = this._rowMap;\n        for (var i = 0, n = rows.size(); i < n; ++i) {\n            var pair = rows.itemAt(i);\n            var symbol = pair.first;\n            if (symbol.type() !== SymbolType.External) {\n                var row = pair.second;\n                var temp = row.coefficientFor(entering);\n                if (temp < 0.0) {\n                    var temp_ratio = -row.constant() / temp;\n                    if (temp_ratio < ratio) {\n                        ratio = temp_ratio;\n                        found = symbol;\n                    }\n                }\n            }\n        }\n        return found;\n    };\n    /**\n     * Compute the leaving symbol for a marker variable.\n     *\n     * This method will return a symbol corresponding to a basic row\n     * which holds the given marker variable. The row will be chosen\n     * according to the following precedence:\n     *\n     * 1) The row with a restricted basic varible and a negative coefficient\n     *    for the marker with the smallest ratio of -constant / coefficient.\n     *\n     * 2) The row with a restricted basic variable and the smallest ratio\n     *    of constant / coefficient.\n     *\n     * 3) The last unrestricted row which contains the marker.\n     *\n     * If the marker does not exist in any row, an invalid symbol will be\n     * returned. This indicates an internal solver error since the marker\n     * *should* exist somewhere in the tableau.\n     *\n     * @private\n     */\n    Solver.prototype._getMarkerLeavingSymbol = function (marker) {\n        var dmax = Number.MAX_VALUE;\n        var r1 = dmax;\n        var r2 = dmax;\n        var invalid = INVALID_SYMBOL;\n        var first = invalid;\n        var second = invalid;\n        var third = invalid;\n        var rows = this._rowMap;\n        for (var i = 0, n = rows.size(); i < n; ++i) {\n            var pair = rows.itemAt(i);\n            var row = pair.second;\n            var c = row.coefficientFor(marker);\n            if (c === 0.0) {\n                continue;\n            }\n            var symbol = pair.first;\n            if (symbol.type() === SymbolType.External) {\n                third = symbol;\n            }\n            else if (c < 0.0) {\n                var r = -row.constant() / c;\n                if (r < r1) {\n                    r1 = r;\n                    first = symbol;\n                }\n            }\n            else {\n                var r = row.constant() / c;\n                if (r < r2) {\n                    r2 = r;\n                    second = symbol;\n                }\n            }\n        }\n        if (first !== invalid) {\n            return first;\n        }\n        if (second !== invalid) {\n            return second;\n        }\n        return third;\n    };\n    /**\n     * Remove the effects of a constraint on the objective function.\n     *\n     * @private\n     */\n    Solver.prototype._removeConstraintEffects = function (cn, tag) {\n        if (tag.marker.type() === SymbolType.Error) {\n            this._removeMarkerEffects(tag.marker, cn.strength());\n        }\n        if (tag.other.type() === SymbolType.Error) {\n            this._removeMarkerEffects(tag.other, cn.strength());\n        }\n    };\n    /**\n     * Remove the effects of an error marker on the objective function.\n     *\n     * @private\n     */\n    Solver.prototype._removeMarkerEffects = function (marker, strength) {\n        var pair = this._rowMap.find(marker);\n        if (pair !== undefined) {\n            this._objective.insertRow(pair.second, -strength);\n        }\n        else {\n            this._objective.insertSymbol(marker, -strength);\n        }\n    };\n    /**\n     * Get the first Slack or Error symbol in the row.\n     *\n     * If no such symbol is present, an invalid symbol will be returned.\n     *\n     * @private\n     */\n    Solver.prototype._anyPivotableSymbol = function (row) {\n        var cells = row.cells();\n        for (var i = 0, n = cells.size(); i < n; ++i) {\n            var pair = cells.itemAt(i);\n            var type = pair.first.type();\n            if (type === SymbolType.Slack || type === SymbolType.Error) {\n                return pair.first;\n            }\n        }\n        return INVALID_SYMBOL;\n    };\n    /**\n     * Returns a new Symbol of the given type.\n     *\n     * @private\n     */\n    Solver.prototype._makeSymbol = function (type) {\n        return new Symbol(type, this._idTick++);\n    };\n    return Solver;\n}());\nexport { Solver };\n/**\n * Test whether a value is approximately zero.\n * @private\n */\nfunction nearZero(value) {\n    var eps = 1.0e-8;\n    return value < 0.0 ? -value < eps : value < eps;\n}\n/**\n * An internal function for creating a constraint map.\n * @private\n */\nfunction createCnMap() {\n    return createMap();\n}\n/**\n * An internal function for creating a row map.\n * @private\n */\nfunction createRowMap() {\n    return createMap();\n}\n/**\n * An internal function for creating a variable map.\n * @private\n */\nfunction createVarMap() {\n    return createMap();\n}\n/**\n * An internal function for creating an edit map.\n * @private\n */\nfunction createEditMap() {\n    return createMap();\n}\n/**\n * An enum defining the available symbol types.\n * @private\n */\nvar SymbolType;\n(function (SymbolType) {\n    SymbolType[SymbolType[\"Invalid\"] = 0] = \"Invalid\";\n    SymbolType[SymbolType[\"External\"] = 1] = \"External\";\n    SymbolType[SymbolType[\"Slack\"] = 2] = \"Slack\";\n    SymbolType[SymbolType[\"Error\"] = 3] = \"Error\";\n    SymbolType[SymbolType[\"Dummy\"] = 4] = \"Dummy\";\n})(SymbolType || (SymbolType = {}));\n/**\n * An internal class representing a symbol in the solver.\n * @private\n */\nvar Symbol = /** @class */ (function () {\n    /**\n     * Construct a new Symbol\n     *\n     * @param [type] The type of the symbol.\n     * @param [id] The unique id number of the symbol.\n     */\n    function Symbol(type, id) {\n        this._id = id;\n        this._type = type;\n    }\n    /**\n     * Returns the unique id number of the symbol.\n     */\n    Symbol.prototype.id = function () {\n        return this._id;\n    };\n    /**\n     * Returns the type of the symbol.\n     */\n    Symbol.prototype.type = function () {\n        return this._type;\n    };\n    return Symbol;\n}());\n/**\n * A static invalid symbol\n * @private\n */\nvar INVALID_SYMBOL = new Symbol(SymbolType.Invalid, -1);\n/**\n * An internal row class used by the solver.\n * @private\n */\nvar Row = /** @class */ (function () {\n    /**\n     * Construct a new Row.\n     */\n    function Row(constant) {\n        if (constant === void 0) { constant = 0.0; }\n        this._cellMap = createMap();\n        this._constant = constant;\n    }\n    /**\n     * Returns the mapping of symbols to coefficients.\n     */\n    Row.prototype.cells = function () {\n        return this._cellMap;\n    };\n    /**\n     * Returns the constant for the row.\n     */\n    Row.prototype.constant = function () {\n        return this._constant;\n    };\n    /**\n     * Returns true if the row is a constant value.\n     */\n    Row.prototype.isConstant = function () {\n        return this._cellMap.empty();\n    };\n    /**\n     * Returns true if the Row has all dummy symbols.\n     */\n    Row.prototype.allDummies = function () {\n        var cells = this._cellMap;\n        for (var i = 0, n = cells.size(); i < n; ++i) {\n            var pair = cells.itemAt(i);\n            if (pair.first.type() !== SymbolType.Dummy) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * Create a copy of the row.\n     */\n    Row.prototype.copy = function () {\n        var theCopy = new Row(this._constant);\n        theCopy._cellMap = this._cellMap.copy();\n        return theCopy;\n    };\n    /**\n     * Add a constant value to the row constant.\n     *\n     * Returns the new value of the constant.\n     */\n    Row.prototype.add = function (value) {\n        return this._constant += value;\n    };\n    /**\n     * Insert the symbol into the row with the given coefficient.\n     *\n     * If the symbol already exists in the row, the coefficient\n     * will be added to the existing coefficient. If the resulting\n     * coefficient is zero, the symbol will be removed from the row.\n     */\n    Row.prototype.insertSymbol = function (symbol, coefficient) {\n        if (coefficient === void 0) { coefficient = 1.0; }\n        var pair = this._cellMap.setDefault(symbol, function () { return 0.0; });\n        if (nearZero(pair.second += coefficient)) {\n            this._cellMap.erase(symbol);\n        }\n    };\n    /**\n     * Insert a row into this row with a given coefficient.\n     *\n     * The constant and the cells of the other row will be\n     * multiplied by the coefficient and added to this row. Any\n     * cell with a resulting coefficient of zero will be removed\n     * from the row.\n     */\n    Row.prototype.insertRow = function (other, coefficient) {\n        if (coefficient === void 0) { coefficient = 1.0; }\n        this._constant += other._constant * coefficient;\n        var cells = other._cellMap;\n        for (var i = 0, n = cells.size(); i < n; ++i) {\n            var pair = cells.itemAt(i);\n            this.insertSymbol(pair.first, pair.second * coefficient);\n        }\n    };\n    /**\n     * Remove a symbol from the row.\n     */\n    Row.prototype.removeSymbol = function (symbol) {\n        this._cellMap.erase(symbol);\n    };\n    /**\n     * Reverse the sign of the constant and cells in the row.\n     */\n    Row.prototype.reverseSign = function () {\n        this._constant = -this._constant;\n        var cells = this._cellMap;\n        for (var i = 0, n = cells.size(); i < n; ++i) {\n            var pair = cells.itemAt(i);\n            pair.second = -pair.second;\n        }\n    };\n    /**\n     * Solve the row for the given symbol.\n     *\n     * This method assumes the row is of the form\n     * a * x + b * y + c = 0 and (assuming solve for x) will modify\n     * the row to represent the right hand side of\n     * x = -b/a * y - c / a. The target symbol will be removed from\n     * the row, and the constant and other cells will be multiplied\n     * by the negative inverse of the target coefficient.\n     *\n     * The given symbol *must* exist in the row.\n     */\n    Row.prototype.solveFor = function (symbol) {\n        var cells = this._cellMap;\n        var pair = cells.erase(symbol);\n        var coeff = -1.0 / pair.second;\n        this._constant *= coeff;\n        for (var i = 0, n = cells.size(); i < n; ++i) {\n            cells.itemAt(i).second *= coeff;\n        }\n    };\n    /**\n     * Solve the row for the given symbols.\n     *\n     * This method assumes the row is of the form\n     * x = b * y + c and will solve the row such that\n     * y = x / b - c / b. The rhs symbol will be removed from the\n     * row, the lhs added, and the result divided by the negative\n     * inverse of the rhs coefficient.\n     *\n     * The lhs symbol *must not* exist in the row, and the rhs\n     * symbol must* exist in the row.\n     */\n    Row.prototype.solveForEx = function (lhs, rhs) {\n        this.insertSymbol(lhs, -1.0);\n        this.solveFor(rhs);\n    };\n    /**\n     * Returns the coefficient for the given symbol.\n     */\n    Row.prototype.coefficientFor = function (symbol) {\n        var pair = this._cellMap.find(symbol);\n        return pair !== undefined ? pair.second : 0.0;\n    };\n    /**\n     * Substitute a symbol with the data from another row.\n     *\n     * Given a row of the form a * x + b and a substitution of the\n     * form x = 3 * y + c the row will be updated to reflect the\n     * expression 3 * a * y + a * c + b.\n     *\n     * If the symbol does not exist in the row, this is a no-op.\n     */\n    Row.prototype.substitute = function (symbol, row) {\n        var pair = this._cellMap.erase(symbol);\n        if (pair !== undefined) {\n            this.insertRow(row, pair.second);\n        }\n    };\n    return Row;\n}());\n","/** @license kiwi.js v1.1.2\n * #------------------------------------------------------------------------------\n * # Copyright (c) 2013, Nucleic Development Team & H. Rutjes.\n * #\n * # Distributed under the terms of the Modified BSD License.\n * #\n * # The full license is in the file COPYING.txt, distributed with this software.\n * #------------------------------------------------------------------------------\n **/\nimport { Solver, Variable } from 'kiwi.js';\n\n/**\n * Applies the given constraints to the objects in-place.\n * A solution is approximated iteratively.\n * Refer to LAYOUT_ENGINE.md for further details.\n * @param {Array} constraints The constraints\n * @param {Function} constraint.base.solve A function that solves the constraint in-place\n * @param {Number} iterations The number of iterations\n * @param {?Object} constants The constants used by constraints\n */\nexport const solveLoose = (constraints, iterations, constants) => {\n  for (let i = 0; i < iterations; i += 1) {\n    for (const constraint of constraints) {\n      constraint.base.solve(constraint, constants);\n    }\n  }\n};\n\n/**\n * Applies the given constraints to the objects in-place.\n * A solution is found exactly for the constraints that are solvable.\n * Any unsolvable constraints will be skipped and a warning logged in the console.\n * Refer to LAYOUT_ENGINE.md for further details.\n * @param {Array} constraints The constraints\n * @param {String} constraint.base.property The property name on `a` and `b` to constrain\n * @param {Function} constraint.base.strict A function returns the constraint in strict form\n * @param {Object} constraint.a The first object to constrain\n * @param {Object} constraint.b The second object to constrain\n * @param {Object} constraint.a.id A unique id for the first object\n * @param {Object} constraint.b.id A unique id for the second object\n * @param {?Object} constants The constants used by constraints\n */\nexport const solveStrict = (constraints, constants) => {\n  const solver = new Solver();\n  const variables = {};\n\n  const variableId = (obj, property) => `${obj.id}_${property}`;\n\n  const addVariable = (obj, property) => {\n    const id = variableId(obj, property);\n\n    if (!variables[id]) {\n      const variable = (variables[id] = new Variable());\n      variable.property = property;\n      variable.obj = obj;\n    }\n  };\n\n  for (const constraint of constraints) {\n    addVariable(constraint.a, constraint.base.property);\n    addVariable(constraint.b, constraint.base.property);\n  }\n\n  let unsolvableCount = 0;\n\n  for (const constraint of constraints) {\n    try {\n      solver.addConstraint(\n        constraint.base.strict(\n          constraint,\n          constants,\n          variables[variableId(constraint.a, constraint.base.property)],\n          variables[variableId(constraint.b, constraint.base.property)]\n        )\n      );\n    } catch (err) {\n      unsolvableCount += 1;\n    }\n  }\n\n  if (unsolvableCount > 0) {\n    console.warn(`Skipped ${unsolvableCount} unsolvable constraints`);\n  }\n\n  solver.updateVariables();\n\n  const variablesList = Object.values(variables);\n\n  for (const variable of variablesList) {\n    variable.obj[variable.property] = variable.value();\n  }\n};\n","/**\n * Constraint base definitions.\n *\n * Refer to LAYOUT_ENGINE.md for descriptions of each constraint.\n *\n * See `solve` function of `solver.js` for constraint specification.\n */\n\nimport { Constraint, Operator, Strength } from 'kiwi.js';\n\n/**\n * Layout constraint in Y for separating rows\n */\nexport const rowConstraint = {\n  property: 'y',\n\n  strict: (constraint, constants, variableA, variableB) =>\n    new Constraint(\n      variableA.minus(variableB),\n      Operator.Ge,\n      constants.spaceY,\n      Strength.required\n    ),\n};\n\n/**\n * Layout constraint in Y for separating layers\n */\nexport const layerConstraint = {\n  property: 'y',\n\n  strict: (constraint, constants, variableA, variableB) =>\n    new Constraint(\n      variableA.minus(variableB),\n      Operator.Ge,\n      constants.layerSpace,\n      Strength.required\n    ),\n};\n\n/**\n * Layout constraint in X for minimising distance from source to target for straight edges\n */\nexport const parallelConstraint = {\n  property: 'x',\n\n  solve: (constraint) => {\n    const { a, b, strength } = constraint;\n    const resolve = strength * (a.x - b.x);\n    a.x -= resolve;\n    b.x += resolve;\n  },\n\n  strict: (constraint, constants, variableA, variableB) =>\n    new Constraint(\n      variableA.minus(variableB),\n      Operator.Eq,\n      0,\n      Strength.create(1, 0, 0, constraint.strength)\n    ),\n};\n\n/**\n * Crossing constraint in X for minimising edge crossings\n */\nexport const crossingConstraint = {\n  property: 'x',\n\n  solve: (constraint) => {\n    const { edgeA, edgeB, separationA, separationB, strength } = constraint;\n\n    // Amount to move each node towards required separation\n    const resolveSource =\n      strength *\n      ((edgeA.sourceNode.x - edgeB.sourceNode.x - separationA) / separationA);\n\n    const resolveTarget =\n      strength *\n      ((edgeA.targetNode.x - edgeB.targetNode.x - separationB) / separationB);\n\n    // Apply the resolve each node\n    edgeA.sourceNode.x -= resolveSource;\n    edgeB.sourceNode.x += resolveSource;\n    edgeA.targetNode.x -= resolveTarget;\n    edgeB.targetNode.x += resolveTarget;\n  },\n};\n\n/**\n * Layout constraint in X for minimum node separation\n */\nexport const separationConstraint = {\n  property: 'x',\n\n  strict: (constraint, constants, variableA, variableB) =>\n    new Constraint(\n      variableB.minus(variableA),\n      Operator.Ge,\n      constraint.separation,\n      Strength.required\n    ),\n};\n","import { HALF_PI, snap, angle, compare, groupByRow } from './common';\nimport { solveLoose, solveStrict } from './solver';\nimport {\n  rowConstraint,\n  layerConstraint,\n  parallelConstraint,\n  crossingConstraint,\n  separationConstraint,\n} from './constraints';\n\n/**\n * Finds positions for the given nodes relative to their edges.\n * Input nodes and edges are updated in-place.\n * Results are stored in the `x, y` properties on nodes.\n * @param {Object} params The layout parameters\n * @param {Array} params.nodes The input nodes\n * @param {Array} params.edges The input edges\n * @param {Object=} params.layers The node layers if specified\n * @param {Number} params.spaceX The minimum gap between nodes in X\n * @param {Number} params.spaceY The minimum gap between nodes in Y\n * @param {Number} params.spreadX Adjusts the gap for each node in X based on the number of connected edges it has\n * @param {Number} params.layerSpaceY The additional gap between nodes in Y between layers\n * @param {Number} params.iterations The number of solver iterations to perform\n * @returns {void}\n */\nexport const layout = ({\n  nodes,\n  edges,\n  layers,\n  spaceX,\n  spaceY,\n  spreadX,\n  layerSpaceY,\n  iterations,\n}) => {\n  // Set initial positions for nodes\n  for (const node of nodes) {\n    node.x = 0;\n    node.y = 0;\n  }\n\n  // Constants used by constraints\n  const constants = {\n    spaceX,\n    spaceY,\n    spreadX,\n    layerSpace: (spaceY + layerSpaceY) * 0.5,\n  };\n\n  // Constraints to separate nodes into rows and layers\n  const rowConstraints = createRowConstraints(edges);\n  const layerConstraints = createLayerConstraints(nodes, layers);\n\n  // Find the node positions given these constraints\n  solveStrict([...rowConstraints, ...layerConstraints], constants, 1);\n\n  // Find the solved rows using the node positions after solving\n  const rows = groupByRow(nodes);\n\n  // Constraints to avoid edges crossing and maintain parallel vertical edges\n  const crossingConstraints = createCrossingConstraints(edges, constants);\n  const parallelConstraints = createParallelConstraints(edges, constants);\n\n  // Solve these constraints iteratively\n  for (let i = 0; i < iterations; i += 1) {\n    solveLoose(crossingConstraints, 1, constants);\n    solveLoose(parallelConstraints, 50, constants);\n  }\n\n  // Constraints to maintain a minimum horizontal node spacing\n  const separationConstraints = createSeparationConstraints(rows, constants);\n\n  // Find the final node positions given these strict constraints\n  solveStrict([...separationConstraints, ...parallelConstraints], constants, 1);\n\n  // Adjust vertical spacing between rows for legibility\n  expandDenseRows(edges, rows, spaceY);\n};\n\n/**\n * Creates row constraints for the given edges.\n * @param {Array} edges The input edges\n * @returns {Array} The constraints\n */\nconst createRowConstraints = (edges) =>\n  edges.map((edge) => ({\n    base: rowConstraint,\n    a: edge.targetNode,\n    b: edge.sourceNode,\n  }));\n\n/**\n * Creates layer constraints for the given nodes and layers.\n * @param {Array} nodes The input nodes\n * @param {Array=} layers The input layers if any\n * @returns {Array} The constraints\n */\nconst createLayerConstraints = (nodes, layers) => {\n  const layerConstraints = [];\n\n  // Early out if no layers defined\n  if (!layers) {\n    return layerConstraints;\n  }\n\n  // Group the nodes for each layer\n  const layerGroups = layers.map((name) =>\n    nodes.filter((node) => node.nearestLayer === name)\n  );\n\n  // For each layer of nodes\n  for (let i = 0; i < layerGroups.length - 1; i += 1) {\n    const layerNodes = layerGroups[i];\n    const nextLayerNodes = layerGroups[i + 1];\n\n    // Create a temporary intermediary node for the layer\n    const intermediary = { id: `layer-${i}`, x: 0, y: 0 };\n\n    // Constrain each node in the layer to above the intermediary\n    for (const node of layerNodes) {\n      layerConstraints.push({\n        base: layerConstraint,\n        a: intermediary,\n        b: node,\n      });\n    }\n\n    // Constrain each node in the next layer to below the intermediary\n    for (const node of nextLayerNodes) {\n      layerConstraints.push({\n        base: layerConstraint,\n        a: node,\n        b: intermediary,\n      });\n    }\n  }\n\n  return layerConstraints;\n};\n\n/**\n * Creates crossing constraints for the given edges.\n * @param {Array} edges The input edges\n * @param {Object} constants The constraint constants\n * @param {Number} constants.spaceX The minimum gap between nodes in X\n * @returns {Array} The constraints\n */\nconst createCrossingConstraints = (edges, constants) => {\n  const { spaceX } = constants;\n  const crossingConstraints = [];\n\n  // For every pair of edges\n  for (let i = 0; i < edges.length; i += 1) {\n    const edgeA = edges[i];\n    const { sourceNode: sourceA, targetNode: targetA } = edgeA;\n\n    // Count the connected edges\n    const edgeADegree =\n      sourceA.sources.length +\n      sourceA.targets.length +\n      targetA.sources.length +\n      targetA.targets.length;\n\n    for (let j = i + 1; j < edges.length; j += 1) {\n      const edgeB = edges[j];\n      const { sourceNode: sourceB, targetNode: targetB } = edgeB;\n\n      // Skip if edges are not intersecting by row so can't cross\n      if (sourceA.row >= targetB.row || targetA.row <= sourceB.row) {\n        continue;\n      }\n\n      // Count the connected edges\n      const edgeBDegree =\n        sourceB.sources.length +\n        sourceB.targets.length +\n        targetB.sources.length +\n        targetB.targets.length;\n\n      crossingConstraints.push({\n        base: crossingConstraint,\n        edgeA: edgeA,\n        edgeB: edgeB,\n        // The required horizontal spacing between connected nodes\n        separationA: sourceA.width * 0.5 + spaceX + sourceB.width * 0.5,\n        separationB: targetA.width * 0.5 + spaceX + targetB.width * 0.5,\n        // Evenly distribute the constraint\n        strength: 1 / Math.max(1, (edgeADegree + edgeBDegree) / 4),\n      });\n    }\n  }\n\n  return crossingConstraints;\n};\n\n/**\n * Creates parallel constraints for the given edges.\n * Returns object with additional arrays that identify these special cases:\n * - edges connected to single-degree nodes at either end\n * - edges connected to single-degree nodes at both ends\n * @param {Array} edges The input edges\n * @returns {Object} An object containing the constraints\n */\nconst createParallelConstraints = (edges) =>\n  edges.map(({ sourceNode, targetNode }) => ({\n    base: parallelConstraint,\n    a: sourceNode,\n    b: targetNode,\n    // Evenly distribute the constraint\n    strength:\n      0.6 /\n      Math.max(1, sourceNode.targets.length + targetNode.sources.length - 2),\n  }));\n\n/**\n * Creates horizontal separation constraints for the given rows of nodes.\n * @param {Array} rows The rows containing nodes\n * @returns {Array} The constraints\n */\nconst createSeparationConstraints = (rows, constants) => {\n  const { spaceX } = constants;\n  const separationConstraints = [];\n\n  // For each row of nodes\n  for (let i = 0; i < rows.length; i += 1) {\n    const rowNodes = rows[i];\n\n    // Stable sort row nodes horizontally, breaks ties with ids\n    rowNodes.sort((a, b) => compare(a.x, b.x, a.id, b.id));\n\n    // Update constraints given updated row node order\n    for (let j = 0; j < rowNodes.length - 1; j += 1) {\n      const nodeA = rowNodes[j];\n      const nodeB = rowNodes[j + 1];\n\n      // Count the connected edges\n      const degreeA = Math.max(\n        1,\n        nodeA.targets.length + nodeA.sources.length - 2\n      );\n      const degreeB = Math.max(\n        1,\n        nodeB.targets.length + nodeB.sources.length - 2\n      );\n\n      // Allow more spacing for nodes with more edges\n      const spread = Math.min(10, degreeA * degreeB * constants.spreadX);\n      const space = snap(spread * spaceX, spaceX);\n\n      separationConstraints.push({\n        base: separationConstraint,\n        a: nodeA,\n        b: nodeB,\n        separation: nodeA.width * 0.5 + space + nodeB.width * 0.5,\n      });\n    }\n  }\n\n  return separationConstraints;\n};\n\n/**\n * Adds additional spacing in Y relative to row density, see function `rowDensity` for definition.\n * Node positions are updated in-place\n * @param {Array} edges The input edges\n * @param {Array} rows The input rows of nodes\n * @param {Number} spaceY The spacing between nodes in Y\n * @param {Number} [scale=1.25] The amount of expansion to apply relative to row density\n * @param {Number} [unit=0.25] The unit size for rounding expansion relative to spaceY\n */\nconst expandDenseRows = (edges, rows, spaceY, scale = 1.25, unit = 0.25) => {\n  const densities = rowDensity(edges);\n  const spaceYUnit = Math.round(spaceY * unit);\n  let currentOffsetY = 0;\n\n  // Add spacing based relative to row density\n  for (let i = 0; i < rows.length - 1; i += 1) {\n    const density = densities[i] || 0;\n\n    // Round offset to a common unit amount to improve vertical rhythm\n    const offsetY = snap(density * scale * spaceY, spaceYUnit);\n    currentOffsetY += offsetY;\n\n    // Apply offset to all nodes following the current node\n    for (const node of rows[i + 1]) {\n      node.y += currentOffsetY;\n    }\n  }\n};\n\n/**\n * Estimates an average 'density' for each row based on average edge angle at that row.\n * Rows with edges close to horizontal are more 'dense' than rows with straight vertical edges.\n * Rows are determined by each edge's source and target node Y positions.\n * Intermediate row edges are assumed always vertical as a simplification, only the start end rows are measured.\n * Returns a list of values in `(0, 1)` where `0` means all edges on that row are vertical and `1` means all horizontal\n * @param {Array} edges The input edges\n * @returns {Array} The density of each row\n */\nconst rowDensity = (edges) => {\n  const rows = {};\n\n  for (const edge of edges) {\n    // Find the normalized angle of the edge source and target nodes, relative to the X axis\n    const edgeAngle =\n      Math.abs(angle(edge.targetNode, edge.sourceNode) - HALF_PI) / HALF_PI;\n\n    const sourceRow = edge.sourceNode.row;\n    const targetRow = edge.targetNode.row - 1;\n\n    // Add angle to the source row total\n    rows[sourceRow] = rows[sourceRow] || [0, 0];\n    rows[sourceRow][0] += edgeAngle;\n    rows[sourceRow][1] += 1;\n\n    if (targetRow !== sourceRow) {\n      // Add angle to the target row total\n      rows[targetRow] = rows[targetRow] || [0, 0];\n      rows[targetRow][0] += edgeAngle;\n      rows[targetRow][1] += 1;\n    }\n  }\n\n  // Find the average angle for each row\n  for (const row in rows) {\n    rows[row] = rows[row][0] / (rows[row][1] || 1);\n  }\n\n  return Object.values(rows);\n};\n","/*\n * The Kedro-Viz Graph Layout Engine\n *\n * Refer to LAYOUT_ENGINE.md for description of the approach.\n */\n\nimport { offsetNode, offsetEdge } from './common';\nimport { layout } from './layout';\nimport { routing } from './routing';\n\nconst defaultOptions = {\n  layout: {\n    spaceX: 14,\n    spaceY: 110,\n    layerSpaceY: 55,\n    spreadX: 2.2,\n    padding: 100,\n    iterations: 25,\n  },\n  routing: {\n    spaceX: 26,\n    spaceY: 28,\n    minPassageGap: 40,\n    stemUnit: 8,\n    stemMinSource: 5,\n    stemMinTarget: 5,\n    stemMax: 20,\n    stemSpaceSource: 6,\n    stemSpaceTarget: 10,\n  },\n};\n\n/**\n * Generates a diagram of the given DAG.\n * Input nodes and edges are updated in-place.\n * Results are stored as `x, y` properties on nodes\n * and `points` properties on edges.\n * @param {Array} nodes The input nodes\n * @param {Array} edges The input edges\n * @param {Object=} layers The node layers if specified\n * @param {Object=} options The graph options\n * @returns {Object} The generated graph\n */\nexport const graph = (nodes, edges, layers, options = defaultOptions) => {\n  addEdgeLinks(nodes, edges);\n  addNearestLayers(nodes, layers);\n\n  layout({ nodes, edges, layers, ...options.layout });\n  routing({ nodes, edges, layers, ...options.routing });\n\n  const size = bounds(nodes, options.layout.padding);\n  nodes.forEach((node) => offsetNode(node, size.min));\n  edges.forEach((edge) => offsetEdge(edge, size.min));\n\n  return {\n    nodes,\n    edges,\n    layers,\n    size,\n  };\n};\n\n/**\n * Adds lists of source edges and target edges to each node in-place\n * @param {Array} nodes The input nodes\n * @param {Array} edges The input edges\n */\nexport const addEdgeLinks = (nodes, edges) => {\n  const nodeById = {};\n\n  for (const node of nodes) {\n    nodeById[node.id] = node;\n    node.targets = [];\n    node.sources = [];\n  }\n\n  for (const edge of edges) {\n    edge.sourceNode = nodeById[edge.source];\n    edge.targetNode = nodeById[edge.target];\n    edge.sourceNode.targets.push(edge);\n    edge.targetNode.sources.push(edge);\n  }\n};\n\n/**\n * Adds the nearest valid layer to each node whilst maintaining the correct layer order\n * @param {Array} nodes The input nodes\n * @param {?Array} layers The input layers\n */\nconst addNearestLayers = (nodes, layers) => {\n  if (layers && layers.length > 0) {\n    // Create the set of valid layers for lookup\n    const validLayers = {};\n    for (const layer of layers) {\n      validLayers[layer] = true;\n    }\n\n    const hasValidLayer = (node) => Boolean(node && node.layer in validLayers);\n    const lastLayer = layers[layers.length - 1];\n\n    // For each node\n    for (const node of nodes) {\n      // Find first descendant node that has a valid layer following rank order (including itself)\n      const layerNode = findNodeBy(\n        // Starting node\n        node,\n        // Next connected nodes to search\n        targetNodes,\n        // Lowest rank first\n        orderRankAscending,\n        // Acceptance criteria\n        hasValidLayer\n      );\n\n      // Assign the nearest layer if found otherwise must be the last layer\n      node.nearestLayer = layerNode ? layerNode.layer : lastLayer;\n    }\n  }\n};\n\n/**\n * Returns the list of target nodes directly connected to the given node\n * @param {Object} node The input node\n * @returns {Array} The target nodes\n */\nconst targetNodes = (node) => node.targets.map((edge) => edge.targetNode);\n\n/**\n * Comparator function for sorting nodes rank ascending\n * @param {Object} nodeA The first input node\n * @param {Object} nodeB The second input node\n * @returns {Number} The signed difference\n */\nconst orderRankAscending = (nodeA, nodeB) => nodeA.rank - nodeB.rank;\n\n/**\n * Starting at the given node and expanding successors, returns the first node accepted in order\n * @param {Object} node The starting node\n * @param {Function} successors A function returning the next nodes to expand\n * @param {Function} order A comparator function used for prioritising successors\n * @param {Function} accept A function that returns true if the current node fits the criteria\n * @param {Object=} visited An object keeping track of nodes already searched\n * @returns {?Object} The first node accepted in order, or undefined if none\n */\nconst findNodeBy = (node, successors, order, accept, visited) => {\n  // If the current node is accepted then return it without further search\n  if (accept(node)) {\n    return node;\n  }\n\n  // Keep track of visited nodes\n  visited = visited || {};\n  visited[node.id] = true;\n\n  const results = successors(node)\n    // Remove successors already visited\n    .filter((successor) => !visited[successor.id])\n    // Order unvisited successors\n    .sort(order)\n    // Search the unvisited successors recursively\n    .map((successor) =>\n      findNodeBy(successor, successors, order, accept, visited)\n    )\n    // Keep only the accepted resulting nodes if any\n    .filter(accept)\n    // Order resulting nodes\n    .sort(order);\n\n  // Return the first node accepted in order, or undefined if none\n  return results[0];\n};\n\n/**\n * Finds the region bounding the given nodes\n * @param {Array} nodes The input nodes\n * @param {Number} padding Additional padding around the bounds\n * @returns {Object} The bounds\n */\nconst bounds = (nodes, padding) => {\n  const size = {\n    min: { x: Infinity, y: Infinity },\n    max: { x: -Infinity, y: -Infinity },\n  };\n\n  for (const node of nodes) {\n    const x = node.x;\n    const y = node.y;\n\n    if (x < size.min.x) {\n      size.min.x = x;\n    }\n    if (x > size.max.x) {\n      size.max.x = x;\n    }\n    if (y < size.min.y) {\n      size.min.y = y;\n    }\n    if (y > size.max.y) {\n      size.max.y = y;\n    }\n  }\n\n  size.width = size.max.x - size.min.x + 2 * padding;\n  size.height = size.max.y - size.min.y + 2 * padding;\n  size.min.x -= padding;\n  size.min.y -= padding;\n\n  return size;\n};\n","import {\n  compare,\n  distance1d,\n  angle,\n  nearestOnLine,\n  groupByRow,\n  nodeLeft,\n  nodeRight,\n  nodeTop,\n  nodeBottom,\n} from './common';\n\n/**\n * Finds positions for the given edges relative to their nodes.\n * Input nodes and edges are updated in-place.\n * Results are stored in the `points` property on edges.\n * @param {Object} params The layout parameters\n * @param {Array} params.nodes The input nodes\n * @param {Array} params.edges The input edges\n * @param {Number} params.spaceX The minimum gap between a node and passing edges in X\n * @param {Number} params.spaceY The minimum gap between a node and passing edges in Y\n * @param {Number} params.minPassageGap The minimum gap between two nodes in which an edge can pass in X\n * @param {Number} params.stemUnit The unit length for edge stems at anchors\n * @param {Number} params.stemMax The maximum length of edge stems at anchors\n * @param {Number} params.stemMinSource The minimum length for edge stems at source anchors\n * @param {Number} params.stemMinTarget The minimum length for edge stems at target anchors\n * @param {Number} params.stemSpaceSource The ideal spacing between edge stems at source anchors\n * @param {Number} params.stemSpaceTarget The ideal spacing between edge stems at target anchors\n * @returns {void}\n */\nexport const routing = ({\n  nodes,\n  edges,\n  spaceX,\n  spaceY,\n  minPassageGap,\n  stemUnit,\n  stemMinSource,\n  stemMinTarget,\n  stemMax,\n  stemSpaceSource,\n  stemSpaceTarget,\n}) => {\n  // Find the rows formed by nodes\n  const rows = groupByRow(nodes);\n\n  // For each node\n  for (const node of nodes) {\n    // Sort the node's target edges by the angle between source and target nodes\n    node.targets.sort((a, b) =>\n      compare(\n        angle(b.sourceNode, b.targetNode),\n        angle(a.sourceNode, a.targetNode)\n      )\n    );\n  }\n\n  // For each edge\n  for (const edge of edges) {\n    const source = edge.sourceNode;\n    const target = edge.targetNode;\n\n    // Initialise result container\n    edge.points = [];\n\n    // Find the ideal gap between edge source anchors\n    const sourceSeparation = Math.min(\n      (source.width - stemSpaceSource) / source.targets.length,\n      stemSpaceSource\n    );\n\n    const sourceEdgeDistance =\n      source.targets.indexOf(edge) - (source.targets.length - 1) * 0.5;\n\n    const sourceOffsetX = sourceSeparation * sourceEdgeDistance;\n\n    // Start at source node offset\n    const startPoint = { x: source.x + sourceOffsetX, y: source.y };\n    let currentPoint = startPoint;\n\n    // For each row between the source and target rows exclusive\n    for (let i = source.row + 1; i < target.row; i += 1) {\n      const firstNode = rows[i][0];\n\n      // Initialise search for next point\n      let nearestPoint = { x: nodeLeft(firstNode) - spaceX, y: firstNode.y };\n      let nearestDistance = Infinity;\n\n      // Extend the row 'to infinity' on each side in X\n      const rowExtended = [\n        { ...firstNode, x: Number.MIN_SAFE_INTEGER },\n        ...rows[i],\n        { ...firstNode, x: Number.MAX_SAFE_INTEGER },\n      ];\n\n      // For each gap between each nodes on the row\n      for (let i = 0; i < rowExtended.length - 1; i += 1) {\n        const node = rowExtended[i];\n        const nextNode = rowExtended[i + 1];\n        const nodeGap = nodeLeft(nextNode) - nodeRight(node);\n\n        // Avoid routing through small gaps, increase bundling\n        if (nodeGap < minPassageGap) {\n          continue;\n        }\n\n        const offsetX = Math.min(spaceX, nodeGap * 0.5);\n\n        // Find the next potential point. Include offset to reduce overlapping edges\n        const candidatePoint = nearestOnLine(\n          currentPoint.x,\n          currentPoint.y,\n          nodeRight(node) + offsetX,\n          nodeTop(node) - spaceY,\n          nodeLeft(nextNode) - offsetX,\n          nodeTop(nextNode) - spaceY\n        );\n\n        const distance = distance1d(currentPoint.x, candidatePoint.x);\n\n        // Early out if diverging\n        if (distance > nearestDistance) {\n          break;\n        }\n\n        // Keep the nearest point\n        if (distance < nearestDistance) {\n          nearestDistance = distance;\n          nearestPoint = candidatePoint;\n        }\n      }\n\n      // Pass the node at nearest point\n      const offsetY = firstNode.height + spaceY;\n      edge.points.push({\n        x: nearestPoint.x + sourceOffsetX,\n        y: nearestPoint.y,\n      });\n      edge.points.push({\n        x: nearestPoint.x + sourceOffsetX,\n        y: nearestPoint.y + offsetY,\n      });\n\n      currentPoint = {\n        x: nearestPoint.x,\n        y: nearestPoint.y + offsetY,\n      };\n    }\n  }\n\n  // For each node\n  for (const node of nodes) {\n    // Sort the node's outgoing edges by the starting angle of the edge path\n    node.targets.sort((a, b) =>\n      compare(\n        angle(b.sourceNode, b.points[0] || b.targetNode),\n        angle(a.sourceNode, a.points[0] || a.targetNode)\n      )\n    );\n    // Sort the node's incoming edges by the ending angle of the edge path\n    node.sources.sort((a, b) =>\n      compare(\n        angle(a.points[a.points.length - 1] || a.sourceNode, a.targetNode),\n        angle(b.points[b.points.length - 1] || b.sourceNode, b.targetNode)\n      )\n    );\n  }\n\n  // For each edge\n  for (const edge of edges) {\n    const source = edge.sourceNode;\n    const target = edge.targetNode;\n\n    // Find the ideal gap between edge source and target anchors\n    const sourceSeparation = Math.min(\n      (source.width - stemSpaceSource) / source.targets.length,\n      stemSpaceSource\n    );\n\n    const targetSeparation = Math.min(\n      (target.width - stemSpaceTarget) / target.sources.length,\n      stemSpaceTarget\n    );\n\n    const sourceEdgeDistance =\n      source.targets.indexOf(edge) - (source.targets.length - 1) * 0.5;\n    const targetEdgeDistance =\n      target.sources.indexOf(edge) - (target.sources.length - 1) * 0.5;\n\n    const sourceOffsetX = sourceSeparation * sourceEdgeDistance;\n    const targetOffsetX = targetSeparation * targetEdgeDistance;\n\n    // Decrease stem length outwards from the middle stem\n    const sourceOffsetY =\n      stemUnit *\n      source.targets.length *\n      (1 - Math.abs(sourceEdgeDistance) / source.targets.length);\n\n    const targetOffsetY =\n      stemUnit *\n      target.sources.length *\n      (1 - Math.abs(targetEdgeDistance) / target.sources.length);\n\n    // Build the source stem for the edge\n    const sourceStem = [\n      {\n        x: source.x + sourceOffsetX,\n        y: nodeBottom(source),\n      },\n      {\n        x: source.x + sourceOffsetX,\n        y: nodeBottom(source) + stemMinSource,\n      },\n      {\n        x: source.x + sourceOffsetX,\n        y:\n          nodeBottom(source) + stemMinSource + Math.min(sourceOffsetY, stemMax),\n      },\n    ];\n\n    // Build the target stem for the edge\n    const targetStem = [\n      {\n        x: target.x + targetOffsetX,\n        y: nodeTop(target) - stemMinTarget - Math.min(targetOffsetY, stemMax),\n      },\n      {\n        x: target.x + targetOffsetX,\n        y: nodeTop(target) - stemMinTarget,\n      },\n      {\n        x: target.x + targetOffsetX,\n        y: nodeTop(target),\n      },\n    ];\n\n    // Combine all points\n    const points = [...sourceStem, ...edge.points, ...targetStem];\n\n    // Fix any invalid points caused by invalid layouts\n    let pointYMax = points[0].y;\n\n    for (const point of points) {\n      // Ensure increasing Y values for each point\n      if (point.y < pointYMax) {\n        point.y = pointYMax;\n      } else {\n        pointYMax = point.y;\n      }\n    }\n\n    // Assign finished points to edge\n    edge.points = points;\n  }\n};\n","import { graph } from './graph';\n\n/**\n * Calculate chart layout with experimental new graphing algorithm\n * This is an extremely expensive operation so we want it to run as infrequently\n * as possible, and keep it separate from other properties (like node.active)\n * which don't affect layout.\n */\nexport const graphNew = ({ nodes, edges, layers }) => {\n  for (const node of nodes) {\n    node.iconSize = node.iconSize || 24;\n    node.icon = node.icon || 'node';\n    const fullName =\n      (node && node.fullName && node.fullName.length) ||\n      (node && node.full_name && node.full_name.length);\n\n    const padding = { x: 20, y: 10 };\n    const textWidth = fullName * 7;\n    const textGap = 6;\n    const innerWidth = node.iconSize + textWidth + textGap;\n\n    node.width = node.width || innerWidth + padding.x * 2;\n    node.height = node.height || node.iconSize + padding.y * 2;\n    node.textOffset = node.textOffset || (innerWidth - textWidth) / 2;\n    node.iconOffset = node.iconOffset || -innerWidth / 2;\n  }\n\n  const result = graph(nodes, edges, layers);\n\n  return {\n    ...result,\n    size: { ...result.size, marginx: 100, marginy: 100 },\n  };\n};\n"],"sourceRoot":""}